// Copyright 2020 Nym Technologies SA
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use nymsphinx::receiver::ReconstructedMessage;
use serde::{Deserialize, Serialize};
use std::convert::TryFrom;
use tokio_tungstenite::tungstenite::protocol::Message as WsMessage;

#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "type", rename_all = "camelCase")]
pub enum ClientRequest {
    #[serde(rename_all = "camelCase")]
    Send {
        message: String,
        recipient: String,
        with_reply_surb: bool,
    },
    SelfAddress,
    #[serde(rename_all = "camelCase")]
    Reply {
        message: String,
        reply_surb: String,
    },
}

impl TryFrom<String> for ClientRequest {
    type Error = serde_json::Error;

    fn try_from(msg: String) -> Result<Self, Self::Error> {
        serde_json::from_str(&msg)
    }
}

impl Into<WsMessage> for ClientRequest {
    fn into(self) -> WsMessage {
        let str_req = serde_json::to_string(&self).unwrap();
        WsMessage::Text(str_req)
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct ReceivedTextMessage {
    pub message: String,
    pub reply_surb: Option<String>,
}

impl<'a> TryFrom<&'a ReconstructedMessage> for ReceivedTextMessage {
    type Error = std::str::Utf8Error;

    fn try_from(reconstructed_message: &ReconstructedMessage) -> Result<Self, Self::Error> {
        Ok(ReceivedTextMessage {
            message: std::str::from_utf8(&reconstructed_message.message)?.to_string(),
            reply_surb: reconstructed_message
                .reply_SURB
                .as_ref()
                .map(|reply_surb| reply_surb.to_base58_string()),
        })
    }
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "type", rename_all = "camelCase")]
pub enum ServerResponse {
    Received(ReceivedTextMessage),
    SelfAddress { address: String },
    Error { message: String },
}

impl ServerResponse {
    pub fn new_error<S: Into<String>>(msg: S) -> Self {
        ServerResponse::Error {
            message: msg.into(),
        }
    }
}

impl TryFrom<String> for ServerResponse {
    type Error = serde_json::Error;

    fn try_from(msg: String) -> Result<Self, <ServerResponse as TryFrom<String>>::Error> {
        serde_json::from_str(&msg)
    }
}

impl Into<WsMessage> for ServerResponse {
    fn into(self) -> WsMessage {
        // it should be safe to call `unwrap` here as the message is generated by the server
        // so if it fails (and consequently panics) it's a bug that should be resolved
        let str_res = serde_json::to_string(&self).unwrap();
        WsMessage::Text(str_res)
    }
}
